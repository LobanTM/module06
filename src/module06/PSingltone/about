Простая реализация Singleton
Один из самых простых способов реализовать паттерн Singleton на языке Java выглядит так:

!!!lazy initialization

public final class Singleton {
    private static Singleton _instance = null;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (_instance == null)
            _instance = new Singleton();
        return _instance;
    }
}
Теперь приведу некоторые объяснения по поводу реализации шаблона.
Конструктор класса необходимо объявить с модификатором видимости private.
Это предотвратит создание экземпляров класса как с помощью класса Singleton,
так и с помощью его наследников. В связи с этим к объявлению класса смело можно дописать модификатор final.
Метод getInstance() создаст ровно один экземпляр класса Singleton. Этот метод объявлен как synchronized.
Сделано это вот почему. В многопоточных программах при одновременном вызове
метода getInstance() из нескольких потоков можно создать несколько экземпляров класса Singleton.
А должен остаться только один!

От модификатора synchronized можно избавиться. Для этого _instance нужно проинициализировать:
private static final Singleton _instance = new Singleton(),
а в методе getInstance() убрать конструкцию "if". Тогда инициализация произойдет во время загрузки класса.
Но использование поздней инициализации (lazy initialization) предпочтительнее в случае,
если создание экземпляра класса занимает много времени. Да и в случае ленивой инициализации есть возможность
обработать возникшие исключитальные ситуации при вызове конструктора.